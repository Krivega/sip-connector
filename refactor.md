## ARCHITECTURE_REVIEW

### Текущее состояние

Класс VideoSendingBalancer объединяет сразу несколько обязанностей:
подписка на события SipConnector
выбор видеосендерa и получение кодека
«балансировка» (расчёт нужных encodings/bitrate/scaleResolutionDownBy)
постановка асинхронных задач в «стек» (stack-promises)
логирование и обработка ошибок
В коде присутствуют «магические» числа и строки, дублирование логики и разно-уровневые абстракции.

### Выявленные проблемы / риски

1. Нарушение SRP
   Метод processSender выполняет бизнес-логику, тогда как класс уже занимается инфраструктурой (подписка, очередь промисов).
   228-255: `228:255:src/videoSendingBalancer/VideoSendingBalancer.ts`
2. Магические значения
   scaleResolutionDownByTarget = 200 149-155
   scaleResolutionDownByTarget = 1 168-182
   Строка формата '<width>x<height>' распарсена напрямую 196-205
   Это затрудняет поддержку и тестирование.
3. Скрытое подавление ошибок
   Метод runStackPromises логирует ошибку и проглатывает её, возвращая undefined, что нарушает ожидаемый контракт Promise<TResult>.
   111-116
4. Потенциально невалидный resultNoChanged
   Объект формируется «вручную», без гарантии соответствия реальным параметрам RTCRtpSendParameters. При изменении контракта — риск рассинхронизации.
   25-34
5. Жёсткая связность с внешними утилитами
   Зависимости (findVideoSender, getCodecFromSender, setEncodingsToSender) подключаются напрямую, что усложняет юнит-тесты.
6. Дублирование кода
   Вычисление maxBitrate и отправка в addToStackScaleResolutionDownBySender повторяется в трёх методах.
   Константы scaleResolutionDownByTarget различаются только числом.
7. Неочевидная очередь промисов
   stack-promises не документирован, труднее понять политики повтора/отмены.

### Рекомендации

1. Разделить ответственность
   VideoSendingBalancer оставить как «контроллер»/facade: подписка на события + делегирование.
   Выделить сервис SenderBalancer (чистая бизнес-логика расчёта параметров).
   Очередь промисов вынести в отдельную абстракцию (TaskQueue).
2. Вынести константы и конфигурацию
   ;
   Аналогично минимальный/максимальный битрейт.
3. Улучшить обработку ошибок
   В runStackPromises пробрасывать ошибку наружу, либо возвращать resultNoChanged явно:
   ;
   Логгер использовать единообразно (logger.error, logger.debug).
4. Типобезопасный resultNoChanged
   Создать фабрику createNoChangedResult(): TResult либо использовать as const.
   Сгенерировать его из RTCRtpSender.getParameters() при инициализации.
5. Стратегия вместо switch
   Использовать отображение «событие → стратегия». Позволит добавлять новые режимы без изменения switch.
   ;
6. Улучшить тестируемость
   Внедрять зависимости через конструктор (DI).
   Покрыть стратегию расчёта параметров юнит-тестами без SipConnector.
7. Документация и комментарии
   Добавить JSDoc к публичным методам, описать формат входных хедеров и ожидаемый результат.
8. Потенциальное кеширование результатов
   Если запросы приходят чаще, чем выполняются изменения, можно кешировать последний применённый scaleResolutionDownBy/bitrate и пропускать идентичные запросы.
   Возможные метрики прогресса
   Сокращение покрытия VideoSendingBalancer в unit-тестах до ≤ 20%, остальное — в новых, мелких модулях.
   100% юнит-тесты бизнес-логики SenderBalancer.
   Показатель cyclomatic complexity каждого метода ≤ 5.
   Удаление всех «магических» чисел из кода-продукта.

---

    Мы обнаружили смешение обязанностей, магические числа и слабую обработку ошибок. Предлагаю:
    Разделить класс на контроллер, сервис стратегий и очередь задач.
    Вынести константы и убрать дублирование.
    Исправить обработку ошибок, сделать resultNoChanged типобезопасным.
    Заменить switch на стратегию.
    Внедрить зависимости через DI для лучшей тестируемости.
    Это уменьшит связность, повысит читаемость и упростит поддержку.

## План рефакторинга VideoSendingBalancer

### Текущие проблемы

1. **Нарушение SRP (Single Responsibility Principle)**
   - Класс объединяет подписку на события, бизнес-логику балансировки, очередь промисов и обработку ошибок
   - Метод `processSender` выполняет бизнес-логику, тогда как класс уже занимается инфраструктурой

2. **Магические числа и строки**
   - `scaleResolutionDownByTarget = 200` (строка 149-155)
   - `scaleResolutionDownByTarget = 1` (строка 168-182)
   - Строка формата `'<width>x<height>'` распарсена напрямую (строки 196-205)

3. **Скрытое подавление ошибок**
   - Метод `runStackPromises` логирует ошибку и проглатывает её, возвращая `undefined`
   - Нарушает ожидаемый контракт `Promise<TResult>`

4. **Потенциально невалидный `resultNoChanged`**
   - Объект формируется «вручную», без гарантии соответствия реальным параметрам `RTCRtpSendParameters`
   - При изменении контракта — риск рассинхронизации

5. **Жёсткая связность с внешними утилитами**
   - Зависимости (`findVideoSender`, `getCodecFromSender`, `setEncodingsToSender`) подключаются напрямую
   - Усложняет юнит-тесты

6. **Дублирование кода**
   - Вычисление `maxBitrate` и отправка в `addToStackScaleResolutionDownBySender` повторяется в трёх методах
   - Константы `scaleResolutionDownByTarget` различаются только числом

7. **Неочевидная очередь промисов**
   - `stack-promises` не документирован, труднее понять политики повтора/отмены
